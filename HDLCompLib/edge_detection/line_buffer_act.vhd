-- -------------------------------------------------------------------------------
-- This file has been automatically generated by the Caph compiler (version 2.8.4d)
-- from file main.cph, on 2018-05-18 at 18:15:47, by <unknown>
-- For more information, see : http://caph.univ-bpclermont.fr
-- -------------------------------------------------------------------------------

library ieee,caph,work;
use ieee.std_logic_1164.all;
use caph.core.all;
use caph.data_types.all;
use ieee.numeric_std.all;
use work.all;
use work.edgeDetectionOk_globals.all;

entity line_buffer is
   port (
    real_size_empty: in std_logic;
    real_size: in std_logic_vector(5 downto 0);
    real_size_rd: out std_logic;
    ext_size_empty: in std_logic;
    ext_size: in std_logic_vector(5 downto 0);
    ext_size_rd: out std_logic;
    in_pel_empty: in std_logic;
    in_pel: in std_logic_vector(7 downto 0);
    in_pel_rd: out std_logic;
    out_pel_full: in std_logic;
    out_pel: out std_logic_vector(7 downto 0);
    out_pel_wr: out std_logic;
    clock: in std_logic;
    reset: in std_logic
    );
end line_buffer;

architecture FSM of line_buffer is
    type t_enum1 is (IDLE,WORK);
    signal state : t_enum1;
    signal n_state : t_enum1;
    signal en_state : boolean;
    signal max_v : unsigned(5 downto 0);
    signal n_max_v : unsigned(5 downto 0);
    signal en_max_v : boolean;
    signal max_h : unsigned(5 downto 0);
    signal n_max_h : unsigned(5 downto 0);
    signal en_max_h : boolean;
    signal cnt_v : unsigned(5 downto 0);
    signal n_cnt_v : unsigned(5 downto 0);
    signal en_cnt_v : boolean;
    signal cnt_h : unsigned(5 downto 0);
    signal n_cnt_h : unsigned(5 downto 0);
    signal en_cnt_h : boolean;
    signal line_buffer : array64_u8;
    signal n_line_buffer : array64_u8;
    signal en_line_buffer : array64_b;
begin
  comb: process(real_size, real_size_empty, ext_size, ext_size_empty, in_pel, in_pel_empty, out_pel_full, line_buffer, cnt_h, cnt_v, max_h, max_v, state)
    variable p_pel : unsigned(7 downto 0);
    variable p_h : unsigned(5 downto 0);
    variable p_v : unsigned(5 downto 0);
    variable n_line_buffer_tmp : array64_u8;
    variable en_line_buffer_tmp : array64_b;
  begin
    -- ext_size.rdy, real_size.rdy, state=IDLE / p_v=ext_size, p_h=real_size, state:=WORK, max_h:=p_h-1, max_v:=p_v
    if ext_size_empty='0' and real_size_empty='0' and state=IDLE then
      p_v := from_std_logic_vector(ext_size,6);
      ext_size_rd <= '1';
      p_h := from_std_logic_vector(real_size,6);
      real_size_rd <= '1';
      n_state <= WORK;
      en_state <= true;
      n_max_h <= (p_h) - (to_unsigned(1,6));
      en_max_h <= true;
      n_max_v <= p_v;
      en_max_v <= true;
      out_pel <= (others => 'X');
      out_pel_wr <= '0';
      in_pel_rd <= '0';
      n_cnt_v <= cnt_v;
      en_cnt_v <= false;
      n_cnt_h <= cnt_h;
      en_cnt_h <= false;
      n_line_buffer <= line_buffer;
      en_line_buffer <= (others => false);
    -- in_pel.rdy, state=WORK, cnt_h < max_h && cnt_v < max_v, out_pel.rdy / p_pel=in_pel, state:=WORK, wr(out_pel,line_buffer[cnt_h]), line_buffer[cnt_h]:=p_pel, cnt_h:=cnt_h+1
    elsif in_pel_empty='0' and state=WORK and (((cnt_h) < (max_h)) AND ((cnt_v) < (max_v))) and out_pel_full='0' then
      p_pel := from_std_logic_vector(in_pel,8);
      in_pel_rd <= '1';
      n_state <= WORK;
      en_state <= true;
      out_pel <= std_logic_vector(line_buffer(to_integer(cnt_h)));
      out_pel_wr <= '1';
      n_cnt_h <= (cnt_h) + (to_unsigned(1,6));
      en_cnt_h <= true;
      real_size_rd <= '0';
      ext_size_rd <= '0';
      n_max_v <= max_v;
      en_max_v <= false;
      n_max_h <= max_h;
      en_max_h <= false;
      n_cnt_v <= cnt_v;
      en_cnt_v <= false;
      n_line_buffer_tmp := line_buffer;
      en_line_buffer_tmp := (others => false);
      n_line_buffer_tmp(to_integer(cnt_h)) := p_pel;
      en_line_buffer_tmp(to_integer(cnt_h)) := true;
      n_line_buffer <= n_line_buffer_tmp;
      en_line_buffer <= en_line_buffer_tmp;
    -- in_pel.rdy, state=WORK, cnt_v < max_v, out_pel.rdy / p_pel=in_pel, state:=WORK, wr(out_pel,line_buffer[cnt_h]), line_buffer[cnt_h]:=p_pel, cnt_h:=0, cnt_v:=cnt_v+1
    elsif in_pel_empty='0' and state=WORK and ((cnt_v) < (max_v-1)) and out_pel_full='0' then
      p_pel := from_std_logic_vector(in_pel,8);
      in_pel_rd <= '1';
      n_state <= WORK;
      en_state <= true;
      out_pel <= std_logic_vector(line_buffer(to_integer(cnt_h)));
      out_pel_wr <= '1';
      n_cnt_h <= to_unsigned(0,6);
      en_cnt_h <= true;
      n_cnt_v <= (cnt_v) + (to_unsigned(1,6));
      en_cnt_v <= true;
      real_size_rd <= '0';
      ext_size_rd <= '0';
      n_max_v <= max_v;
      en_max_v <= false;
      n_max_h <= max_h;
      en_max_h <= false;
      n_line_buffer_tmp := line_buffer;
      en_line_buffer_tmp := (others => false);
      n_line_buffer_tmp(to_integer(cnt_h)) := p_pel;
      en_line_buffer_tmp(to_integer(cnt_h)) := true;
      n_line_buffer <= n_line_buffer_tmp;
      en_line_buffer <= en_line_buffer_tmp;
    -- in_pel.rdy, state=WORK, out_pel.rdy / p_pel=in_pel, state:=IDLE, wr(out_pel,line_buffer[cnt_h]), line_buffer[cnt_h]:=p_pel, cnt_h:=0, cnt_v:=0
    elsif in_pel_empty='0' and state=WORK and out_pel_full='0' then
      p_pel := from_std_logic_vector(in_pel,8);
      in_pel_rd <= '1';
      n_state <= IDLE;
      en_state <= true;
      out_pel <= std_logic_vector(line_buffer(to_integer(cnt_h)));
      out_pel_wr <= '1';
      n_cnt_h <= to_unsigned(0,6);
      en_cnt_h <= true;
      n_cnt_v <= to_unsigned(0,6);
      en_cnt_v <= true;
      real_size_rd <= '0';
      ext_size_rd <= '0';
      n_max_v <= max_v;
      en_max_v <= false;
      n_max_h <= max_h;
      en_max_h <= false;
      n_line_buffer_tmp := line_buffer;
      en_line_buffer_tmp := (others => false);
      n_line_buffer_tmp(to_integer(cnt_h)) := p_pel;
      en_line_buffer_tmp(to_integer(cnt_h)) := true;
      n_line_buffer <= n_line_buffer_tmp;
      en_line_buffer <= en_line_buffer_tmp;
    else
      real_size_rd <= '0';
      ext_size_rd <= '0';
      in_pel_rd <= '0';
      out_pel_wr <= '0';
      out_pel <= (others => 'X');
      en_state <= false;
      en_max_v <= false;
      en_max_h <= false;
      en_cnt_v <= false;
      en_cnt_h <= false;
      en_line_buffer <= (others => false);
      n_state <= state;
      n_max_v <= max_v;
      n_max_h <= max_h;
      n_cnt_v <= cnt_v;
      n_cnt_h <= cnt_h;
      n_line_buffer <= line_buffer;
    end if;
  end process;
  seq: process(clock, reset)
  begin
    if (reset='0') then
      state <= IDLE;
      max_v <= "000000";
      max_h <= "000000";
      cnt_v <= "000000";
      cnt_h <= "000000";
      line_buffer(0) <= "00000000";
      line_buffer(1) <= "00000000";
      line_buffer(2) <= "00000000";
      line_buffer(3) <= "00000000";
      line_buffer(4) <= "00000000";
      line_buffer(5) <= "00000000";
      line_buffer(6) <= "00000000";
      line_buffer(7) <= "00000000";
      line_buffer(8) <= "00000000";
      line_buffer(9) <= "00000000";
      line_buffer(10) <= "00000000";
      line_buffer(11) <= "00000000";
      line_buffer(12) <= "00000000";
      line_buffer(13) <= "00000000";
      line_buffer(14) <= "00000000";
      line_buffer(15) <= "00000000";
      line_buffer(16) <= "00000000";
      line_buffer(17) <= "00000000";
      line_buffer(18) <= "00000000";
      line_buffer(19) <= "00000000";
      line_buffer(20) <= "00000000";
      line_buffer(21) <= "00000000";
      line_buffer(22) <= "00000000";
      line_buffer(23) <= "00000000";
      line_buffer(24) <= "00000000";
      line_buffer(25) <= "00000000";
      line_buffer(26) <= "00000000";
      line_buffer(27) <= "00000000";
      line_buffer(28) <= "00000000";
      line_buffer(29) <= "00000000";
      line_buffer(30) <= "00000000";
      line_buffer(31) <= "00000000";
      line_buffer(32) <= "00000000";
      line_buffer(33) <= "00000000";
      line_buffer(34) <= "00000000";
      line_buffer(35) <= "00000000";
      line_buffer(36) <= "00000000";
      line_buffer(37) <= "00000000";
      line_buffer(38) <= "00000000";
      line_buffer(39) <= "00000000";
      line_buffer(40) <= "00000000";
      line_buffer(41) <= "00000000";
      line_buffer(42) <= "00000000";
      line_buffer(43) <= "00000000";
      line_buffer(44) <= "00000000";
      line_buffer(45) <= "00000000";
      line_buffer(46) <= "00000000";
      line_buffer(47) <= "00000000";
      line_buffer(48) <= "00000000";
      line_buffer(49) <= "00000000";
      line_buffer(50) <= "00000000";
      line_buffer(51) <= "00000000";
      line_buffer(52) <= "00000000";
      line_buffer(53) <= "00000000";
      line_buffer(54) <= "00000000";
      line_buffer(55) <= "00000000";
      line_buffer(56) <= "00000000";
      line_buffer(57) <= "00000000";
      line_buffer(58) <= "00000000";
      line_buffer(59) <= "00000000";
      line_buffer(60) <= "00000000";
      line_buffer(61) <= "00000000";
      line_buffer(62) <= "00000000";
      line_buffer(63) <= "00000000";
    elsif rising_edge(clock) then
      if ( en_state ) then
        state <= n_state after 1 ns;
      end if;
      if ( en_max_v ) then
        max_v <= n_max_v after 1 ns;
      end if;
      if ( en_max_h ) then
        max_h <= n_max_h after 1 ns;
      end if;
      if ( en_cnt_v ) then
        cnt_v <= n_cnt_v after 1 ns;
      end if;
      if ( en_cnt_h ) then
        cnt_h <= n_cnt_h after 1 ns;
      end if;
      for i1 in 0 to 63 loop
        if ( en_line_buffer(i1) ) then
          line_buffer(i1) <= n_line_buffer(i1) after 1 ns;
        end if;
      end loop;
    end if;
  end process;
end FSM;
